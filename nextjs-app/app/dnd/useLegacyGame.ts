/* eslint-disable */
import { useEffect } from 'react'

export function useLegacyGame() {
  useEffect(() => {
        let gameState = { character: { name: "Adventurer", class: "Fighter", level: 1, hp: { current: 10, max: 10 }, ac: 10, stats: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 }, inventory: [ { name: "Longsword", type: "weapon", icon: "⚔️", quantity: 1 }, { name: "Leather Armor", type: "armor", icon: "🛡️", quantity: 1 }, { name: "Healing Potion", type: "potion", icon: "🧪", quantity: 2 }, { name: "Torch", type: "misc", icon: "🔦", quantity: 5 }, { name: "Gold Pieces", type: "misc", icon: "🪙", quantity: 50 } ], conditions: [], experience: 0 }, world: { location: "The Yawning Portal", time: "evening", weather: "clear", atmosphere: "bustling" }, combat: { active: false, round: 0, combatants: [] }, map: { currentRoom: "tavern", explored: ["tavern"], tokens: [] }, journal: { entries: [], quests: [] }, flags: { tutorial: true, resting: false }, conversation: [] };
        const adventureModules = { 'wild-sheep-chase': { name: "The Wild Sheep Chase", description: "A light-hearted adventure full of polymorphed sheep and wizard grudges", startingLocation: "Market Square", initialPrompt: "You're browsing the market stalls when suddenly a sheep runs up to you, bleating frantically. It seems to be trying to communicate something..." }, 'skyhorn-lighthouse': { name: "Secrets of Skyhorn Lighthouse", description: "A water-themed adventure with pirates and underwater mysteries", startingLocation: "Coastal Town Docks", initialPrompt: "The salty sea air fills your lungs as you arrive at the docks. The lighthouse keeper has been missing for days, and strange lights have been seen..." }, 'grammys-pie': { name: "Grammy's Country Apple Pie", description: "A comedic adventure where cosmic forces battle over the perfect pie", startingLocation: "The Countryside", initialPrompt: "The wizard Tyndareus has hired you for what seems like a simple task - retrieve his favorite apple pie from Grammy's Bakery. What could go wrong?" } };
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
        const DM_SYSTEM_PROMPT = `You are an immersive AI Dungeon Master for D&D 5th Edition. Your role is to create a cinematic, engaging experience where the player focuses purely on roleplay and storytelling.\nCRITICAL RULES:\n1. NEVER mention game mechanics to the player (no dice rolls, AC, DC, stats, etc.)\n2. Handle ALL mechanical calculations silently using the provided functions\n3. Present outcomes as natural narrative consequences\n4. Focus on immersive storytelling and vivid descriptions\nYour responsibilities:\n- Narrate with rich, sensory details\n- Control all NPCs with distinct personalities\n- Secretly roll all dice and determine outcomes\n- Track all game mechanics behind the scenes\n- Create dramatic, cinematic moments\n- Respond creatively to player actions\n- Maintain tension and pacing\nWhen combat occurs:\n- Describe attacks and defenses cinematically\n- Use the dice roll functions but don't mention them\n- Update HP silently and describe injuries narratively\n- Make combat feel dangerous and exciting\nAlways:\n- Ask "What do you do?" to prompt player action\n- Give players meaningful choices\n- React to player creativity positively\n- Use the functions to track everything\n- Keep the story moving forward\nCurrent Setting: [Will be provided based on chosen adventure]\nRemember: The player should feel like they're in an interactive movie, not playing a game with numbers.`;
        const dmFunctions = [ { name: "roll_dice", description: "Secretly roll dice for any check, save, or attack. Player should never know about these rolls.", parameters: { type: "object", properties: { num_dice: { type: "integer", description: "Number of dice" }, dice_type: { type: "integer", enum: [4, 6, 8, 10, 12, 20, 100] }, modifier: { type: "integer", description: "Modifier to add" }, dc: { type: "integer", description: "Difficulty Class if applicable" }, roll_type: { type: "string", enum: ["attack", "damage", "save", "check", "initiative"], description: "Type of roll being made" }, hidden: { type: "boolean", description: "Always true - rolls are always hidden from player" } }, required: ["num_dice", "dice_type", "roll_type", "hidden"] } }, { name: "update_character_hp", description: "Silently update character HP. Describe injuries/healing narratively without numbers.", parameters: { type: "object", properties: { target: { type: "string", description: "Character name or 'player'" }, hp_change: { type: "integer", description: "Negative for damage, positive for healing" }, damage_type: { type: "string", description: "Type of damage/healing" }, current_hp: { type: "integer", description: "Current HP after change" }, max_hp: { type: "integer", description: "Maximum HP" } }, required: ["target", "hp_change", "current_hp", "max_hp"] } }, { name: "manage_inventory", description: "Add or remove items from inventory silently", parameters: { type: "object", properties: { action: { type: "string", enum: ["add", "remove", "use"] }, item_name: { type: "string" }, quantity: { type: "integer" }, item_type: { type: "string", enum: ["weapon", "armor", "potion", "treasure", "misc"] }, effect: { type: "string", description: "Effect if item is used" } }, required: ["action", "item_name", "quantity"] } }, { name: "update_world_state", description: "Update location, time, atmosphere, or other world elements", parameters: { type: "object", properties: { location: { type: "string", description: "New location name" }, time: { type: "string", description: "Time of day" }, weather: { type: "string", description: "Weather conditions" }, atmosphere: { type: "string", description: "Mood/atmosphere of the scene" } } } }, { name: "manage_combat", description: "Handle combat state and tracking", parameters: { type: "object", properties: { action: { type: "string", enum: ["start", "end", "add_combatant", "remove_combatant", "next_turn"] }, combatants: { type: "array", items: { type: "object", properties: { name: { type: "string" }, hp: { type: "integer" }, ac: { type: "integer" }, initiative: { type: "integer" } } } } }, required: ["action"] } }, { name: "update_map", description: "Update map tokens and positions", parameters: { type: "object", properties: { action: { type: "string", enum: ["add_token", "move_token", "remove_token", "reveal_area"] }, token_id: { type: "string" }, token_type: { type: "string", enum: ["player", "enemy", "npc", "object"] }, x: { type: "integer" }, y: { type: "integer" }, area: { type: "string", description: "Area to reveal on map" } }, required: ["action"] } }, { name: "add_journal_entry", description: "Add important events or discoveries to the player's journal", parameters: { type: "object", properties: { entry_type: { type: "string", enum: ["quest", "discovery", "npc", "location", "lore"] }, title: { type: "string" }, content: { type: "string" }, important: { type: "boolean" } }, required: ["entry_type", "title", "content"] } }, { name: "grant_experience", description: "Award XP for accomplishments, silently track progression", parameters: { type: "object", properties: { amount: { type: "integer", description: "XP amount" }, reason: { type: "string", description: "What earned the XP" }, level_up: { type: "boolean", description: "If this causes a level up" } }, required: ["amount", "reason"] } }, { name: "apply_condition", description: "Apply or remove conditions (poisoned, frightened, etc)", parameters: { type: "object", properties: { action: { type: "string", enum: ["add", "remove"] }, condition: { type: "string" }, duration: { type: "string", description: "How long it lasts" }, effect: { type: "string", description: "Narrative effect" } }, required: ["action", "condition"] } } ];
        document.addEventListener('DOMContentLoaded', () => { initializeGame(); });
        function initializeGame() { setupEventListeners(); loadGameState(); updateCharacterDisplay(); updateInventoryDisplay(); document.getElementById('action-input').focus(); startAmbientEffects(); }
        function setupEventListeners() { const actionInput = document.getElementById('action-input'); actionInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { handlePlayerAction(); } }); actionInput.addEventListener('focus', () => { document.getElementById('quick-actions').classList.add('visible'); }); actionInput.addEventListener('blur', () => { setTimeout(() => { document.getElementById('quick-actions').classList.remove('visible'); }, 200); }); window.addEventListener('click', (e) => { if (e.target.id === 'overlay-bg') { closeAllPanels(); } }); }
        async function handlePlayerAction() { const input = document.getElementById('action-input'); const action = input.value.trim(); if (!action) return; addStoryMessage(action, 'action'); input.value = ''; showLoadingMessage(); try { const response = await callGeminiAPI(action); processAIResponse(response); } catch (error) { hideLoadingMessage(); addStoryMessage("The mystical connection wavers... (Check your API key in settings)", 'system'); console.error('API Error:', error); } }
        async function callGeminiAPI(playerAction) { const apiKey = document.getElementById('api-key').value; const messages = [ { role: "user", parts: [{ text: DM_SYSTEM_PROMPT + `\n\nCurrent game state:\n${JSON.stringify(gameState, null, 2)}` }] }, ...gameState.conversation.slice(-10).map(msg => ({ role: msg.role === 'player' ? 'user' : 'model', parts: [{ text: msg.content }] })), { role: "user", parts: [{ text: `Player action: ${playerAction}` }] } ]; const requestBody = { contents: messages, tools: [{ function_declarations: dmFunctions }], generationConfig: { temperature: 0.9, topK: 40, topP: 0.95, maxOutputTokens: 2048 } }; const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) }); if (!response.ok) { throw new Error(`API request failed: ${response.status}`); } return await response.json(); }
        async function processAIResponse(response) { hideLoadingMessage(); if (!response.candidates || response.candidates.length === 0) { addStoryMessage("The fates remain silent...", 'system'); return; } const candidate = response.candidates[0]; const content = candidate.content; if (content.parts) { for (const part of content.parts) { if (part.functionCall) { await executeFunctionCall(part.functionCall); } else if (part.text) { addStoryMessage(part.text, 'narration'); gameState.conversation.push({ role: 'dm', content: part.text }); } } } saveGameState(); }
        async function executeFunctionCall(functionCall) { const { name, args } = functionCall; switch (name) { case 'roll_dice': return rollDiceSilently(args); case 'update_character_hp': updateCharacterHP(args); break; case 'manage_inventory': manageInventory(args); break; case 'update_world_state': updateWorldState(args); break; case 'manage_combat': manageCombat(args); break; case 'update_map': updateMap(args); break; case 'add_journal_entry': addJournalEntry(args); break; case 'grant_experience': grantExperience(args); break; case 'apply_condition': applyCondition(args); break; } }
        function rollDiceSilently({ num_dice, dice_type, modifier = 0, dc = null }) { let total = 0; const rolls = []; for (let i = 0; i < num_dice; i++) { const roll = Math.floor(Math.random() * dice_type) + 1; rolls.push(roll); total += roll; } total += modifier; return { total, rolls, success: dc ? total >= dc : null }; }
        function updateCharacterHP({ target, hp_change, current_hp, max_hp }) { if (target === 'player' || target === gameState.character.name) { const oldHp = gameState.character.hp.current; gameState.character.hp.current = current_hp; gameState.character.hp.max = max_hp; const healthFill = document.getElementById('health-fill'); const percentage = (current_hp / max_hp) * 100; healthFill.style.width = `${percentage}%`; if (hp_change !== 0) { showFloatingNumber(hp_change); } updateCharacterDisplay(); if (current_hp <= 0 && oldHp > 0) { addStoryMessage("Darkness closes in...", 'combat'); } } }
        function manageInventory({ action, item_name, quantity, item_type, effect }) { if (action === 'add') { const existing = gameState.character.inventory.find(i => i.name === item_name); if (existing) { existing.quantity += quantity; } else { gameState.character.inventory.push({ name: item_name, type: item_type || 'misc', icon: getItemIcon(item_type), quantity: quantity }); } } else if (action === 'remove' || action === 'use') { const itemIndex = gameState.character.inventory.findIndex(i => i.name === item_name); if (itemIndex !== -1) { gameState.character.inventory[itemIndex].quantity -= quantity; if (gameState.character.inventory[itemIndex].quantity <= 0) { gameState.character.inventory.splice(itemIndex, 1); } } } updateInventoryDisplay(); }
        function updateWorldState({ location, time, weather, atmosphere }) { if (location) { gameState.world.location = location; document.getElementById('location-tag').textContent = location; } if (time) gameState.world.time = time; if (weather) gameState.world.weather = weather; if (atmosphere) gameState.world.atmosphere = atmosphere; }
        function manageCombat({ action, combatants }) { if (action === 'start') { gameState.combat.active = true; gameState.combat.combatants = combatants || []; document.body.style.animation = 'combatShake 0.5s'; } else if (action === 'end') { gameState.combat.active = false; gameState.combat.combatants = []; document.body.style.animation = ''; } }
        function updateMap({ action, token_id, token_type, x, y, area }) { const mapCanvas = document.getElementById('map-canvas'); if (action === 'add_token') { const token = document.createElement('div'); token.className = `map-token ${token_type}`; token.id = token_id; token.style.left = `${x * 40}px`; token.style.top = `${y * 40}px`; token.innerHTML = getTokenIcon(token_type); mapCanvas.appendChild(token); gameState.map.tokens.push({ id: token_id, type: token_type, x, y }); } else if (action === 'move_token') { const token = document.getElementById(token_id); if (token) { token.style.left = `${x * 40}px`; token.style.top = `${y * 40}px`; } } }
        function addJournalEntry({ entry_type, title, content, important }) { const entry = { type: entry_type, title: title, content: content, timestamp: new Date().toISOString(), important: important }; gameState.journal.entries.push(entry); if (important) { showAchievement('📜', `Discovery: ${title}`); } }
        function grantExperience({ amount, reason, level_up }) { gameState.character.experience += amount; if (level_up) { gameState.character.level += 1; showAchievement('⭐', `Level ${gameState.character.level}!`); updateCharacterDisplay(); } }
        function applyCondition({ action, condition, duration, effect }) { if (action === 'add') { gameState.character.conditions.push({ name: condition, duration: duration, effect: effect }); } else if (action === 'remove') { gameState.character.conditions = gameState.character.conditions.filter(c => c.name !== condition); } }
        function addStoryMessage(content, type) { const storyDisplay = document.getElementById('story-display'); const message = document.createElement('div'); message.className = `story-message ${type}`; if (type === 'action') { message.innerHTML = `<p>» <em>${content}</em></p>`; } else if (type === 'dialogue') { message.innerHTML = `<p>${content}</p>`; } else { message.innerHTML = `<p>${content}</p>`; } storyDisplay.appendChild(message); message.scrollIntoView({ behavior: 'smooth', block: 'end' }); }
        function showLoadingMessage() { const storyDisplay = document.getElementById('story-display'); const loading = document.createElement('div'); loading.id = 'loading-message'; loading.className = 'loading-message'; loading.innerHTML = `<span>The Dungeon Master contemplates</span><div class="loading-dots"><div class="loading-dot"></div><div class="loading-dot"></div><div class="loading-dot"></div></div>`; storyDisplay.appendChild(loading); loading.scrollIntoView({ behavior: 'smooth' }); }
        function hideLoadingMessage() { const loading = document.getElementById('loading-message'); if (loading) loading.remove(); }
        function showFloatingNumber(amount) { const number = document.createElement('div'); number.className = amount > 0 ? 'damage-number heal-number' : 'damage-number'; number.textContent = amount > 0 ? `+${amount}` : amount; number.style.left = '50%'; number.style.top = '30%'; document.body.appendChild(number); setTimeout(() => number.remove(), 1500); }
        function showAchievement(icon, text) { const toast = document.createElement('div'); toast.className = 'achievement-toast'; toast.innerHTML = `<div class="achievement-icon">${icon}</div><div class="achievement-text">${text}</div>`; document.body.appendChild(toast); setTimeout(() => toast.remove(), 4000); }
        function toggleFabMenu() { const menu = document.getElementById('fab-menu'); const fab = document.getElementById('fab'); menu.classList.toggle('active'); fab.style.transform = menu.classList.contains('active') ? 'rotate(180deg)' : ''; }
        function openPanel(panelName) { const panel = document.getElementById(`${panelName}-panel`); const overlay = document.getElementById('overlay-bg'); panel.classList.add('active'); overlay.classList.add('active'); toggleFabMenu(); }
        function closePanel(panelName) { const panel = document.getElementById(`${panelName}-panel`); panel.classList.remove('active'); const openPanels = document.querySelectorAll('.slide-panel.active, .map-overlay.active'); if (openPanels.length === 0) { document.getElementById('overlay-bg').classList.remove('active'); } }
        function closeAllPanels() { document.querySelectorAll('.slide-panel').forEach(panel => { panel.classList.remove('active'); }); document.getElementById('map-overlay').classList.remove('active'); document.getElementById('overlay-bg').classList.remove('active'); }
        function openMapOverlay() { const overlay = document.getElementById('map-overlay'); const bg = document.getElementById('overlay-bg'); overlay.classList.add('active'); bg.classList.add('active'); toggleFabMenu(); if (gameState.map.tokens.length === 0) { updateMap({ action: 'add_token', token_id: 'player-token', token_type: 'player', x: 5, y: 5 }); } }
        function closeMapOverlay() { document.getElementById('map-overlay').classList.remove('active'); const openPanels = document.querySelectorAll('.slide-panel.active'); if (openPanels.length === 0) { document.getElementById('overlay-bg').classList.remove('active'); } }
        function openSettings() { document.getElementById('settings-modal').classList.add('active'); document.getElementById('overlay-bg').classList.add('active'); }
        function closeSettings() { document.getElementById('settings-modal').classList.remove('active'); const characterName = document.getElementById('character-name-input').value; if (characterName) { gameState.character.name = characterName; updateCharacterDisplay(); } const openPanels = document.querySelectorAll('.slide-panel.active'); if (openPanels.length === 0) { document.getElementById('overlay-bg').classList.remove('active'); } saveGameState(); }
        function quickAction(action) { document.getElementById('action-input').value = action; handlePlayerAction(); }
        function updateCharacterDisplay() { document.getElementById('character-name').textContent = gameState.character.name; document.getElementById('level').textContent = gameState.character.level; document.getElementById('class').textContent = gameState.character.class; document.getElementById('hp').textContent = `${gameState.character.hp.current}/${gameState.character.hp.max}`; document.getElementById('ac').textContent = gameState.character.ac; Object.keys(gameState.character.stats).forEach(stat => { const element = document.getElementById(stat); if (element) element.textContent = gameState.character.stats[stat]; }); }
        function updateInventoryDisplay() { const inventoryList = document.getElementById('inventory-list'); inventoryList.innerHTML = ''; gameState.character.inventory.forEach(item => { const itemDiv = document.createElement('div'); itemDiv.className = 'inventory-item'; itemDiv.innerHTML = `<div class="item-icon-large">${item.icon}</div><div class="item-details"><div class="item-name">${item.name}</div><div class="item-type">${item.type}</div></div>${item.quantity > 1 ? `<div class="item-quantity">×${item.quantity}</div>` : ''}`; itemDiv.onclick = () => { closePanel('inventory'); document.getElementById('action-input').value = `I use my ${item.name}`; handlePlayerAction(); }; inventoryList.appendChild(itemDiv); }); }
        function filterInventory(type) { document.querySelectorAll('.filter-btn').forEach(btn => { btn.classList.remove('active'); }); event.target.classList.add('active'); updateInventoryDisplay(); }
        function getItemIcon(type) { const icons = { weapon: '⚔️', armor: '🛡️', potion: '🧪', treasure: '💎', misc: '📜' }; return icons[type] || '📦'; }
        function getTokenIcon(type) { const icons = { player: '🦸', enemy: '👹', npc: '🧙', object: '📍' }; return icons[type] || '❓'; }
        function saveGameState() { localStorage.setItem('dnd-immersive-state', JSON.stringify(gameState)); localStorage.setItem('dnd-api-key', document.getElementById('api-key').value); }
        function loadGameState() { const saved = localStorage.getItem('dnd-immersive-state'); if (saved) { gameState = JSON.parse(saved); updateCharacterDisplay(); updateInventoryDisplay(); document.getElementById('location-tag').textContent = gameState.world.location; const percentage = (gameState.character.hp.current / gameState.character.hp.max) * 100; document.getElementById('health-fill').style.width = `${percentage}%`; } const savedKey = localStorage.getItem('dnd-api-key'); if (savedKey) { document.getElementById('api-key').value = savedKey; } }
        function startAmbientEffects() { setInterval(() => { if (Math.random() < 0.1 && !gameState.combat.active) { } }, 30000); }
        setInterval(saveGameState, 60000);
        const style = document.createElement('style'); style.textContent = `@keyframes combatShake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-2px); } 75% { transform: translateX(2px); } }`; document.head.appendChild(style);
  }, [])
}


